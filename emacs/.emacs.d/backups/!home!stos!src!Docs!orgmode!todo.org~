* How To's
* Tasks
** Work Tasks

**  YAKS
*** Data care
**** TODO clean up bash history, saving only useful commands.


* Testing in DNA-M

** The Testing Pyramid

*** Unit tests (checks)
As a developer (including testers) write unit tests where ever possible.
Unit  tests  are not  really about finding bugs, but is about safe guarding existing functionality
while code is being modified, refactored, or new code is being written.
Also as some form of documentation on how to use your code.
Encourages code to be testable.
*Exisiting unit test will fail after changes, and will need to be modified to accomodate new behavour.*


Unit tests should be:

- *Fast*
- *Isolated (targeted at a single class if possible)*
- *Repeatable*

Dont aim for 100% coverage, aim for covering the general use of the class interface
Does anyone here practice TDD?

Practicalities:
In DNA-M we have mainly used:
 - JUnit 4 library
- Hamcrest matchers
  + Hamcrest allows to write specialized matchers
- Mockito
  + Plain Old Java
  + Mockito annotations (using  _@RunWith(MockitoJUnitRunner.class)_ )

 - "unit" tests can be annotated internal DNA-M annotations declaring test type
_@Category(IntegrationTest.class)_
see the package _se/transmode/tnm/test/categories_
The annotations are parsed and sorted by  gradle

- Before checking in code, the developer should run unit tests locally.

_> ./gradlew unitTest_

Maybe its just enough to run tests related to the module/project where changes are being made e.g.

_> ./gradlew model_lib:test_

Also keep your eyes on the pipeline after checkin.....
http://se-tnmbuild.infinera.com

Don't "Commit and Run"

*** Integration tests
- Integration tests are about the interaction between classes and other components like databases:

_> ./gradlew integTest_

I've got a feeling that all other tests that are annotated with a category are classed as "integration tests"

*** Acceptance like  tests
These tests probably  require startup and configuration of nodes (docker), a running server,
and maybe other components.
The ideal situation would be to do "specification by example"
i.e. a Jira story describes the "acceptance criteria" or "done criteria"
as a small set of examples. Tests covering the examples are written and must *always* pass.

*** Manual tests
Taken care of  in regression by exploratory testing.

** Examples of unit tests, integration tests, and anything inbetween
- Mockito  e.g. _AlarmEAOTest.java_
- Layer2 model dsl e.g. _ModelsForTest.java_
- Layer2 Assurance _FlowDomainFragmentAssuranceTest.java_
- SNMP readers e.g. _BasicSignalEntryTest.java_
- Passive board  e.g. _AddDropTest_
- Board test e.g. _Mxp10GOtnWithXcTest.java_ here is an example of a Matcher

- Acceptance tests e.g. _RouteInfoExportRestAssuredTest.java_
  + Look at how we setup the docker nodes jenkins job. http://se-tnmbuild/view/Network%20Test/
  + DNA-M is deployed with preprepared Db with docker nodes. http://se-tnmbuild/job/deployment/job/tnmNetTest/
  + Jenkins job runs the tests in a seperate pipeline.
  + Other  "test" interfaces used in DNA-M (secret REST interface).


* Logging in DNA-M

** Simple Logging Facade for Java (SLF4J)
Provides a common interface for different logging libraries, which can be changed at compile time, by changing the slf4j logging implementation
available on the class path. !SIMPLES!
Logging uses the LOMBOK _@Slf4j_ annotation. Delombok a file to see whats happening behined the scenes.

See this link for a diagram over all the "drop-ins" for the different logging frameworks covered by slf4j
 - https://www.slf4j.org/manual.html

** Libraries in DNA-M
In  _libs.gradle_ the actual/real logging framework is given.
*Notice* lots of excludes for logging in various packages to sync versions to *one and only one* version of the various libraries.

Mainly we use Logback.  Logback is intended as a successor to the popular log4j project. Other projects or modules may use other implementations.
Log-stash is used somewhere in the project, for logging metrics.

** Some code
All logging configuration for logback is controlled by _LoggingConfig.java_
Before the logging config is initiated, logging has to be instantiated per class, usually only needed in the AppMain classes.

** Logging practicalities
Logging can be enabled/disabled in the dev environment. See the config module.
Usually logged to the working directory/build

Debug logging is disabled in production
Config files are found in /etc/tnm/ on a linux machine.
Config files are found in C:\<where_ever>\transmode\tnm\conf
Config files for the windows client are found under the installation \bin directory and under the <user>\apps\roaming... client.par
On windows client debug seems to be enabled by default.
Can be enabled at runtime by Removing the *.DISABLED* extension.

_logback.xml_
_logback-debug.xml_
_logback-logstash.xml_
_logback-file-appenders.xml_ (hidden away under resources). This file will say how logs are partiitioned to the various log files.

The syntax of these files are described by the logback documentation:
https://logback.qos.ch/manual/configuration.html
** Syslog
See the file _SysLoggerImpl.java_
Syslog configured from the servergui.
Events and stuff logged to the given syslog if enabled. How much? How often? Your guess is as good as mine.

* Jenkins Pipeline
  Once upon a time it was simple, but then came software developers...

** To Cover
+ Transition phase between old GUI configuration and the new jenkins declarative/scripted style pipeline.
+ Look at existing main pipelines and interesting jobs
+ Cover the piplines that are now created on branching (new style pipelines)
+ which gradle jobs are triggered and which switches are used.

** List of interesting pipelines
+ DNA-M pipeline
    + Old and new
+ Mimic Load Test pipelines and Health checks
    + Deploy scripts maybe interesting to look at.
    + Health check scripts

** List of standalone Jobs
+ deploy with parameters.
+ deploy to TNM.

** New vs Old
The new jenkins pipeline syntax can be found at https://jenkins.io/doc/book/pipeline/syntax/
+ 2 versions of the new syntax
+ Hooks into bitbucket
+ Docker CI containers

* DNA-M Server communications
Begin with a diagram of _all known_ interfaces :-)

** Interserver and client-server communication
This is all RMI based communication, but in 2 different ways:

1. Straight RMI service based:
+ For an example ClientGuiAppMain and ServerAppMain
+ There RMI registry creation is shown and then registration of  the various service interfaces.

2. Session based request-response
+ Message processing ClientServiceUtil
  - Session object export which exposes process()
  - createSession method in SessionMgr
  - every client has own RMI via Session Object
  - Examples AlarmService (server) - AlarmServiceUtil (client)
  - MTOSI service - MtosiServiceUtil

3. For the RMI interface for WebApp server (springboot) nearly all Services are exposed via RMI

4. Can be enabled with RMI over SSL
+ certs and keystores location
+ configuration 

** Database communication
+ Datasource implementation
  + General datasource for database requests and jdbc
     - Configurable by properties table.
  + Pooled datasource for EDU processing (needed by Camel file processing)
  + Datasource for Flyway Migrat
** Internal REST server
Start at the subserver handler and go from there.
+ RestServerModule defines 2 types:
  - Jersey
  - Spark
** PCEP (Path Computation Engine Protocol)
+ Check the Library...your guess is as good as mine
  - Maybe PceSessionManager
** AMQP Rabbit communication
The amqp project and notifications:
+ The amqp configuration
+ Amqp eventbus bridge publish/subscribe model
+ Message definitions in amqpmodel
  - amqp me




* Emerge after F12
** sudo emerge media-fonts/dejavu
** sudo emerge xkill
** sudo emerge app-misc/colordiff
** sudo emerge app-text/tree
** sudo emerge x11-misc/arandr
** sudo emerge hsetroot
** sudo emerge xsetroot
** sudo emerge trayer-srg
** sudo emerge net-misc/tigervnc
** sudo emerge dev-java/maven-bin
** sudo emerge app-admin/stow
** sudo emerge app-emulation/docker-compose
** sudo emerge genlop
** sudo emerge xmlstarlet
** sudo emerge evince
